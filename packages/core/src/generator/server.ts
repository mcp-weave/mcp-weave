import type { McpSpec } from '../spec/types.js';

/**
 * Server generation options
 */
export interface GeneratorOptions {
  outputDir: string;
  framework?: 'nestjs' | 'express';
  transport?: 'stdio' | 'sse';
}

/**
 * Generated file
 */
export interface GeneratedFile {
  path: string;
  content: string;
}

/**
 * Generate MCP server code from spec
 */
export function generateServer(spec: McpSpec, options: GeneratorOptions): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  
  // Generate main server file
  files.push({
    path: `${options.outputDir}/server.ts`,
    content: generateServerFile(spec),
  });

  // Generate tools file if tools exist
  if (spec.tools && spec.tools.length > 0) {
    files.push({
      path: `${options.outputDir}/tools.ts`,
      content: generateToolsFile(spec),
    });
  }

  // Generate resources file if resources exist
  if (spec.resources && spec.resources.length > 0) {
    files.push({
      path: `${options.outputDir}/resources.ts`,
      content: generateResourcesFile(spec),
    });
  }

  // Generate prompts file if prompts exist
  if (spec.prompts && spec.prompts.length > 0) {
    files.push({
      path: `${options.outputDir}/prompts.ts`,
      content: generatePromptsFile(spec),
    });
  }

  // Generate index file
  files.push({
    path: `${options.outputDir}/index.ts`,
    content: generateIndexFile(spec),
  });

  return files;
}

function generateServerFile(spec: McpSpec): string {
  return `// Generated by MCP-Weave
// Server: ${spec.server.name} v${spec.server.version}

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';

export const server = new Server(
  {
    name: '${spec.server.name}',
    version: '${spec.server.version}',
  },
  {
    capabilities: {
      tools: ${spec.tools && spec.tools.length > 0 ? '{}' : 'undefined'},
      resources: ${spec.resources && spec.resources.length > 0 ? '{}' : 'undefined'},
      prompts: ${spec.prompts && spec.prompts.length > 0 ? '{}' : 'undefined'},
    },
  }
);

export async function startServer() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error(\`${spec.server.name} server running on stdio\`);
}
`;
}

function generateToolsFile(spec: McpSpec): string {
  const tools = spec.tools ?? [];
  return `// Generated by MCP-Weave - Tools

import { server } from './server.js';

${tools.map(tool => `
// Tool: ${tool.name}
// ${tool.description}
server.setRequestHandler(
  { method: 'tools/call' },
  async (request) => {
    if (request.params.name === '${tool.name}') {
      const args = request.params.arguments ?? {};
      // TODO: Implement ${tool.name} logic
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({ success: true, tool: '${tool.name}', args }),
          },
        ],
      };
    }
    throw new Error(\`Unknown tool: \${request.params.name}\`);
  }
);

server.setRequestHandler(
  { method: 'tools/list' },
  async () => ({
    tools: [
      ${tools.map(t => `{
        name: '${t.name}',
        description: '${t.description}',
        inputSchema: ${JSON.stringify(t.inputSchema ?? { type: 'object', properties: {} })},
      }`).join(',\n      ')}
    ],
  })
);
`).join('\n')}
`;
}

function generateResourcesFile(spec: McpSpec): string {
  const resources = spec.resources ?? [];
  return `// Generated by MCP-Weave - Resources

import { server } from './server.js';

server.setRequestHandler(
  { method: 'resources/list' },
  async () => ({
    resources: [
      ${resources.map(r => `{
        uri: '${r.uri}',
        name: '${r.name}',
        description: '${r.description ?? ''}',
        mimeType: '${r.mimeType}',
      }`).join(',\n      ')}
    ],
  })
);

server.setRequestHandler(
  { method: 'resources/read' },
  async (request) => {
    const uri = request.params.uri;
    // TODO: Implement resource reading logic
    return {
      contents: [
        {
          uri,
          mimeType: 'application/json',
          text: JSON.stringify({ resource: uri }),
        },
      ],
    };
  }
);
`;
}

function generatePromptsFile(spec: McpSpec): string {
  const prompts = spec.prompts ?? [];
  return `// Generated by MCP-Weave - Prompts

import { server } from './server.js';

server.setRequestHandler(
  { method: 'prompts/list' },
  async () => ({
    prompts: [
      ${prompts.map(p => `{
        name: '${p.name}',
        description: '${p.description}',
        arguments: ${JSON.stringify(p.arguments ?? [])},
      }`).join(',\n      ')}
    ],
  })
);

server.setRequestHandler(
  { method: 'prompts/get' },
  async (request) => {
    const name = request.params.name;
    const args = request.params.arguments ?? {};
    // TODO: Implement prompt generation logic
    return {
      messages: [
        {
          role: 'user',
          content: {
            type: 'text',
            text: \`Prompt: \${name}, args: \${JSON.stringify(args)}\`,
          },
        },
      ],
    };
  }
);
`;
}

function generateIndexFile(spec: McpSpec): string {
  const imports = ['./server.js'];
  if (spec.tools && spec.tools.length > 0) imports.push('./tools.js');
  if (spec.resources && spec.resources.length > 0) imports.push('./resources.js');
  if (spec.prompts && spec.prompts.length > 0) imports.push('./prompts.js');

  return `// Generated by MCP-Weave
// ${spec.server.description ?? spec.server.name}

${imports.map(i => `import '${i}';`).join('\n')}
import { startServer } from './server.js';

startServer().catch(console.error);
`;
}
